P -> 				{ offset = 0; }
     D 				{ S.next = newlabel(); }
     S				{ gen('L' S.next ':'); }

D -> L id;			{ top.set(id.lexeme, L.type, offset); 
					  offset = offset + L.width; }
	 D1

D -> Îµ				  

L -> int			{ L.type = integer; L.width = 4; }
L -> float			{ L.type = float; L.width = 8; }

S -> id = E;		{ gen(id.lexeme ':=' E.name); }

S -> if (			{ C.true = fall; C.false = S.next; }
	 C )            { S1.next = S.next; }
	 S1

S -> if (			{ C.true = fall; C.false = newlabel(); }
	 C )			{ S1.next = S.next; }
	 S1				{ gen('goto L' S.next); }
	 else			{ S2.next = S.next; gen('L' C.false ':'); }
	 S2

S -> while (		{ while.begin = newlabel(); gen('L' while.begin ':');
					  C.true = fall; C.false = S.next; }
	 C )			{ S1.next = while.begin; }
	 S1				{ gen('goto L' while.begin); }

S -> 				{ S1.next = newlabel(); }
	 S1				{ S2.next = S.next; gen('L' S1.next ':'); }
	 S2

# When rel is '==', the rel in gen is '='
# And for any operation, operands should be widen
C -> E1 rel E2		{ condition = E1.name ' rel ' E2.name
					  if C.true != fall and C.false != fall then
					  	gen('if' condition 'goto' C.true); || gen ('goto' C.false);
					  else if C.true != fall then gen('if' condition 'goto L' C.true);
					  else if C.false != fall then gen('ifFalse' condition 'goto L' C.false);
					  else ''; }

E -> E1 +/- T 		{ E.name = newtemp(); gen(E.name ':=' E1.name '+'/'-' T.name); }
E -> T 				{ E.name = T.name; }

T -> F 				{ T.name = F.name; }
T -> T1 */`/` F 	{ T.name = newtemp(); gen(T.name ':=' T1.name '*'/'/' F.name); }

F -> ( E ) 			{ F.name = E.name; }
F -> id				{ F.name = id.lexeme; }
F -> decimal 		{ F.name = decimal.value; }