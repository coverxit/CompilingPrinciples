using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Windows.Forms;

using Microsoft.CSharp;
using System.CodeDom;
using System.CodeDom.Compiler;

using CompilingPrinciples.LexerCore;
using CompilingPrinciples.SymbolEnvironment;
using CompilingPrinciples.ParserCore;

namespace CompilingPrinciples.Utility
{
    public static class CompilerHelper
    {
        private static CodeCompileUnit GenerateParserCompileUnit(string sourceFilePath)
        {
            var mainStmts = new CodeStatement[]
            {
                // var symbolTable = new SymbolTable();
                new CodeVariableDeclarationStatement(
                    new CodeTypeReference(typeof(SymbolTable)), "symbolTable",
                    new CodeObjectCreateExpression(typeof(SymbolTable))
                ),
                
                // var ctxStream = new FileStream(ctxPath, FileMode.Open)
                new CodeVariableDeclarationStatement(
                    new CodeTypeReference(typeof(FileStream)), "ctxStream",
                    new CodeObjectCreateExpression(
                        typeof(FileStream),
                        new CodePrimitiveExpression(Path.GetFileNameWithoutExtension(sourceFilePath) + ".ctx"),
                        new CodePropertyReferenceExpression(
                            new CodeTypeReferenceExpression(typeof(FileMode)), "Open"
                        )
                    )
                ),

                // Parser parser = Parser.CreateFromContext(ctxStream, symbolTable, null, new ParseStepReporter());
                new CodeVariableDeclarationStatement(
                    new CodeTypeReference(typeof(Parser)), "parser",
                    new CodeMethodInvokeExpression(
                        new CodeTypeReferenceExpression(typeof(Parser)), "CreateFromContext",
                        new CodeVariableReferenceExpression("ctxStream"),
                        new CodeVariableReferenceExpression("symbolTable"),
                        new CodePrimitiveExpression(null),
                        new CodeObjectCreateExpression(new CodeTypeReference("ParseStepReporter"), new CodeExpression[] { })
                    )
                ),

                // var inputStream = Console.OpenStandardInput();
                new CodeVariableDeclarationStatement(
                    new CodeTypeReference(typeof(Stream)), "inputStream",
                    new CodeMethodInvokeExpression(
                        new CodeTypeReferenceExpression(typeof(Console)), "OpenStandardInput"
                    )
                ),

                // empty line
                new CodeSnippetStatement(""),

                // Console.WriteLine("{0,-40} {1}", "SYMBOLS", "ACTION");
                new CodeExpressionStatement(
                    new CodeMethodInvokeExpression(
                        new CodeTypeReferenceExpression(typeof(Console)), "WriteLine",
                        new CodePrimitiveExpression("{0,-40} {1}"),
                        new CodePrimitiveExpression("SYMBOLS"),
                        new CodePrimitiveExpression("ACTION")
                    )
                ),

                // parser.Parse(inputStream);
                new CodeExpressionStatement(
                    new CodeMethodInvokeExpression(
                        new CodeVariableReferenceExpression("parser"), "Parse",
                        new CodeVariableReferenceExpression("inputStream")
                    )
                ),
                
                // empty line
                new CodeSnippetStatement(""),

                // ctxStream.Close();
                new CodeExpressionStatement(
                    new CodeMethodInvokeExpression(
                        new CodeMethodReferenceExpression(
                            new CodeVariableReferenceExpression("ctxStream"), "Close"
                        )
                    )
                ),

                // inputStream.Close();
                new CodeExpressionStatement(
                    new CodeMethodInvokeExpression(
                        new CodeMethodReferenceExpression(
                            new CodeVariableReferenceExpression("inputStream"), "Close"
                        )
                    )
                )
            };

            // public static void Main(string[] args)
            var entryPoint = new CodeEntryPointMethod();
            foreach (var s in mainStmts)
                entryPoint.Statements.Add(s);

            // class Program
            var parserClass = new CodeTypeDeclaration("Program");
            parserClass.Attributes = MemberAttributes.Public;
            parserClass.IsClass = true;
            parserClass.Members.Add(entryPoint);
            parserClass.Comments.Add(new CodeCommentStatement("Generated by Shindo's Parser Generator"));

            var funcStmts = new CodeStatement[]
            {
                // Console.WriteLine("{0,-40} {1}", symbol, action);
                new CodeExpressionStatement (
                    new CodeMethodInvokeExpression(
                        new CodeTypeReferenceExpression(typeof(Console)), "WriteLine",
                        new CodePrimitiveExpression("{0,-40} {1}"),
                        new CodeVariableReferenceExpression("symbol"),
                        new CodeVariableReferenceExpression("action")
                    )
                )
            };

            // public void ReportStep(bool error, stirng action, string stack, string symbol)
            var reportStepFunc = new CodeMemberMethod();
            reportStepFunc.Name = "ReportStep";
            reportStepFunc.Attributes = MemberAttributes.Public;
            reportStepFunc.Parameters.AddRange(new CodeParameterDeclarationExpression[]
            {
                new CodeParameterDeclarationExpression(new CodeTypeReference(typeof(bool)), "error"),
                new CodeParameterDeclarationExpression(new CodeTypeReference(typeof(string)), "action"),
                new CodeParameterDeclarationExpression(new CodeTypeReference(typeof(string)), "stack"),
                new CodeParameterDeclarationExpression(new CodeTypeReference(typeof(string)), "symbol")
            });
            foreach (var s in funcStmts)
                reportStepFunc.Statements.Add(s);

            // class ParseStepReporter : IReportParseStep
            var stepReporterClass = new CodeTypeDeclaration("ParseStepReporter");
            stepReporterClass.BaseTypes.Add(new CodeTypeReference(typeof(IReportParseStep)));
            stepReporterClass.Attributes = MemberAttributes.Public;
            stepReporterClass.IsClass = true;
            stepReporterClass.Members.Add(reportStepFunc);

            var ns = new CodeNamespace("AutoGeneratedParser");
            ns.Imports.Add(new CodeNamespaceImport("System"));
            ns.Types.Add(parserClass);
            ns.Types.Add(stepReporterClass);

            // unit
            var unit = new CodeCompileUnit();
            unit.Namespaces.Add(ns);
            return unit;
        }

        public static string CompileParser(string sourceFilePath)
        {
            var appPath = Path.GetDirectoryName(Application.ExecutablePath) + "\\";

            var codeProvider = CodeDomProvider.CreateProvider(
                Path.GetExtension(sourceFilePath) == ".cs" ? "CSharp" : "VisualBasic"
            );
            var sw = new StringWriter();

            var cu = GenerateParserCompileUnit(sourceFilePath);
            codeProvider.GenerateCodeFromCompileUnit(cu, sw, null);

            var param = new CompilerParameters();
            param.GenerateExecutable = true;
            param.OutputAssembly = Path.ChangeExtension(sourceFilePath, "exe");
            param.ReferencedAssemblies.Add("System.Xml.Linq.dll");
            param.ReferencedAssemblies.Add(appPath + "LexerCore.dll");
            param.ReferencedAssemblies.Add(appPath + "ParserCore.dll");
            codeProvider.CompileAssemblyFromDom(param, cu);

            // Copy dlls
            if (Path.GetDirectoryName(sourceFilePath) != Path.GetDirectoryName(Application.ExecutablePath))
            {
                var destPath = Path.GetDirectoryName(sourceFilePath) + "\\";

                try
                {
                    File.Copy(appPath + "LexerCore.dll", destPath + "LexerCore.dll");
                    File.Copy(appPath + "ParserCore.dll", destPath + "ParserCore.dll");
                }
                catch (Exception)
                { }
            }

            return sw.ToString();
        }   
    }
}
